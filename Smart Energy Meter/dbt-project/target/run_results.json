{"metadata": {"dbt_schema_version": "https://schemas.getdbt.com/dbt/run-results/v5.json", "dbt_version": "1.7.0", "generated_at": "2025-12-16T12:36:22.355868Z", "invocation_id": "3423e4cf-2d5b-401f-a4f1-3494ae334803", "env": {}}, "results": [{"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-16T12:36:20.599488Z", "completed_at": "2025-12-16T12:36:20.699346Z"}, {"name": "execute", "started_at": "2025-12-16T12:36:20.722380Z", "completed_at": "2025-12-16T12:36:21.157162Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.5617122650146484, "adapter_response": {"_message": "SUCCESS", "rows_affected": 0, "query": "/* {\"app\": \"dbt\", \"dbt_version\": \"1.7.0\", \"profile_name\": \"smart_energy_meter\", \"target_name\": \"dev\", \"node_id\": \"model.smart_energy_meter.stg_meter_health_logs\"} */\ninsert into \"iceberg\".\"energy_data_staging\".\"stg_meter_health_logs\" (\"log_id\", \"log_timestamp\", \"log_level\", \"device_id\", \"customer_id\", \"health_event\", \"health_status\", \"battery_pct\", \"voltage_v\", \"temperature_c\", \"memory_usage_pct\", \"uptime_hours\", \"error_count\", \"raw_log_message\", \"processed_at\")\n    (\n        select \"log_id\", \"log_timestamp\", \"log_level\", \"device_id\", \"customer_id\", \"health_event\", \"health_status\", \"battery_pct\", \"voltage_v\", \"temperature_c\", \"memory_usage_pct\", \"uptime_hours\", \"error_count\", \"raw_log_message\", \"processed_at\"\n        from \"iceberg\".\"energy_data_staging\".\"stg_meter_health_logs__dbt_tmp\"\n    )", "query_id": "20251216_123324_01789_g7hqv"}, "message": "SUCCESS", "failures": null, "unique_id": "model.smart_energy_meter.stg_meter_health_logs", "compiled": true, "compiled_code": "\n\n-- Staging model: Parse UNSTRUCTURED health logs from Kafka\n-- This model reads plain text logs and extracts structured data using regex and string functions\n-- Input: kafka.default.meter_logs (plain text, multiple formats)\n-- Output: iceberg.energy_data_staging.stg_meter_health_logs (structured)\n\nWITH raw_logs AS (\n    SELECT\n        _message as raw_log_message,\n        _timestamp as kafka_timestamp,\n        _key as device_id_key\n    FROM \"kafka\".\"default\".\"meter_logs\"\n    WHERE _message IS NOT NULL\n      AND _message != ''\n),\n\nparsed_logs AS (\n    SELECT\n        raw_log_message,\n        kafka_timestamp,\n        device_id_key,\n\n        -- Extract timestamp (first datetime pattern in log)\n        regexp_extract(raw_log_message, '(\\d{4}-\\d{2}-\\d{2}\\s+\\d{2}:\\d{2}:\\d{2})', 1) as log_timestamp_str,\n\n        -- Extract log level (INFO, WARN, ERROR, CRITICAL)\n        regexp_extract(raw_log_message, '\\[(INFO|WARN|ERROR|CRITICAL)\\]', 1) as log_level,\n\n        -- Extract device_id (MTR-\\d+ pattern)\n        regexp_extract(raw_log_message, '(MTR-\\d+)', 1) as device_id,\n\n        -- Extract customer_id (CUST-\\d+ pattern)\n        regexp_extract(raw_log_message, '(CUST-\\d+)', 1) as customer_id,\n\n        -- Extract health event (all caps with underscores)\n        regexp_extract(raw_log_message, '(HEALTH_CHECK_OK|HEALTH_CHECK_DEGRADED|BATTERY_LOW|VOLTAGE_ANOMALY|CONNECTIVITY_ISSUE|SENSOR_FAULT|CALIBRATION_DRIFT|MEMORY_WARNING|TEMPERATURE_HIGH|FIRMWARE_UPDATE_REQUIRED)', 1) as health_event,\n\n        -- Extract health status\n        regexp_extract(raw_log_message, 'status=(\\w+)', 1) as health_status_raw,\n        regexp_extract(raw_log_message, 'Status: (\\w+)', 1) as health_status_alt,\n        regexp_extract(raw_log_message, 'status is (\\w+)', 1) as health_status_nl,\n\n        -- Extract battery percentage\n        CAST(regexp_extract(raw_log_message, 'battery=(\\d+)', 1) AS INTEGER) as battery_pct,\n\n        -- Extract voltage\n        CAST(regexp_extract(raw_log_message, 'voltage=([0-9.]+)', 1) AS DOUBLE) as voltage_v,\n\n        -- Extract temperature\n        CAST(regexp_extract(raw_log_message, 'temp=([0-9.]+)', 1) AS DOUBLE) as temperature_c,\n\n        -- Extract memory usage\n        CAST(regexp_extract(raw_log_message, 'memory=(\\d+)', 1) AS INTEGER) as memory_usage_pct,\n        CAST(regexp_extract(raw_log_message, 'mem=(\\d+)', 1) AS INTEGER) as memory_usage_alt,\n\n        -- Extract uptime\n        CAST(regexp_extract(raw_log_message, 'uptime=(\\d+)', 1) AS INTEGER) as uptime_hours,\n        CAST(regexp_extract(raw_log_message, 'up=(\\d+)', 1) AS INTEGER) as uptime_hours_alt,\n\n        -- Extract error count\n        CAST(regexp_extract(raw_log_message, 'errors=(\\d+)', 1) AS INTEGER) as error_count,\n        CAST(regexp_extract(raw_log_message, 'err_cnt=(\\d+)', 1) AS INTEGER) as error_count_alt\n\n    FROM raw_logs\n),\n\ncleaned_logs AS (\n    SELECT\n        raw_log_message,\n        kafka_timestamp,\n\n        -- Parse timestamp\n        CASE\n            WHEN log_timestamp_str IS NOT NULL AND log_timestamp_str != ''\n            THEN CAST(from_iso8601_timestamp(REPLACE(log_timestamp_str, ' ', 'T') || 'Z') AS TIMESTAMP(6))\n            ELSE CAST(CURRENT_TIMESTAMP AS TIMESTAMP(6))\n        END as log_timestamp,\n\n        log_level,\n        device_id,\n        customer_id,\n        health_event,\n\n        -- Consolidate health_status from multiple extraction patterns\n        COALESCE(health_status_raw, health_status_alt, health_status_nl, 'UNKNOWN') as health_status,\n\n        battery_pct,\n        voltage_v,\n        temperature_c,\n\n        -- Consolidate memory and uptime from multiple patterns\n        COALESCE(memory_usage_pct, memory_usage_alt) as memory_usage_pct,\n        COALESCE(uptime_hours, uptime_hours_alt) as uptime_hours,\n        COALESCE(error_count, error_count_alt, 0) as error_count\n\n    FROM parsed_logs\n    WHERE device_id IS NOT NULL  -- Only keep logs with identifiable device\n)\n\nSELECT\n    lower(to_hex(md5(to_utf8(cast(coalesce(cast(device_id as varchar), '_dbt_utils_surrogate_key_null_') || '-' || coalesce(cast(log_timestamp as varchar), '_dbt_utils_surrogate_key_null_') || '-' || coalesce(cast(raw_log_message as varchar), '_dbt_utils_surrogate_key_null_') as varchar))))) as log_id,\n    log_timestamp,\n    log_level,\n    device_id,\n    customer_id,\n    health_event,\n    health_status,\n    battery_pct,\n    voltage_v,\n    temperature_c,\n    memory_usage_pct,\n    uptime_hours,\n    error_count,\n    raw_log_message,\n    CAST(CURRENT_TIMESTAMP AS TIMESTAMP(6)) as processed_at\nFROM cleaned_logs\n\n\n    WHERE log_timestamp > (SELECT COALESCE(MAX(log_timestamp), TIMESTAMP '2000-01-01 00:00:00') FROM \"iceberg\".\"energy_data_staging\".\"stg_meter_health_logs\")\n", "relation_name": "\"iceberg\".\"energy_data_staging\".\"stg_meter_health_logs\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-16T12:36:20.620181Z", "completed_at": "2025-12-16T12:36:20.698622Z"}, {"name": "execute", "started_at": "2025-12-16T12:36:20.701349Z", "completed_at": "2025-12-16T12:36:21.685373Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 1.0903675556182861, "adapter_response": {"_message": "SUCCESS", "rows_affected": 0, "query": "/* {\"app\": \"dbt\", \"dbt_version\": \"1.7.0\", \"profile_name\": \"smart_energy_meter\", \"target_name\": \"dev\", \"node_id\": \"model.smart_energy_meter.stg_telemetry_raw\"} */\ninsert into \"iceberg\".\"energy_data_staging\".\"stg_telemetry_raw\" (\"telemetry_id\", \"device_id\", \"customer_id\", \"reading_timestamp\", \"energy_kwh\", \"voltage\", \"battery_pct\", \"status\", \"ingested_at\")\n    (\n        select \"telemetry_id\", \"device_id\", \"customer_id\", \"reading_timestamp\", \"energy_kwh\", \"voltage\", \"battery_pct\", \"status\", \"ingested_at\"\n        from \"iceberg\".\"energy_data_staging\".\"stg_telemetry_raw__dbt_tmp\"\n    )", "query_id": "20251216_123324_01788_g7hqv"}, "message": "SUCCESS", "failures": null, "unique_id": "model.smart_energy_meter.stg_telemetry_raw", "compiled": true, "compiled_code": "\n\n-- Staging model: Ingest data from Kafka to Iceberg\n-- This model reads from kafka.default.telemetry_raw and writes to iceberg.energy_data_staging.stg_telemetry_raw\n-- JSON parsing is done at dbt level using CAST(json_parse()) for scalability\n\nWITH parsed_json AS (\n    SELECT\n        CAST(json_parse(_message) AS ROW(\n            device_id VARCHAR,\n            customer_id VARCHAR,\n            timestamp VARCHAR,\n            metrics ROW(energy_kwh DOUBLE, voltage DOUBLE, battery_pct BIGINT),\n            status VARCHAR\n        )) as msg,\n        _timestamp as kafka_timestamp\n    FROM \"kafka\".\"default\".\"telemetry_raw\"\n    WHERE _message IS NOT NULL\n      AND _message != ''\n),\n\nsource_data AS (\n    SELECT\n        msg.device_id as device_id,\n        msg.customer_id as customer_id,\n        msg.timestamp as timestamp,\n        msg.metrics.energy_kwh as metrics_energy_kwh,\n        msg.metrics.voltage as metrics_voltage,\n        msg.metrics.battery_pct as metrics_battery_pct,\n        msg.status as status,\n        kafka_timestamp\n    FROM parsed_json\n)\n\nSELECT\n    lower(to_hex(md5(to_utf8(cast(coalesce(cast(device_id as varchar), '_dbt_utils_surrogate_key_null_') || '-' || coalesce(cast(timestamp as varchar), '_dbt_utils_surrogate_key_null_') as varchar))))) as telemetry_id,\n    device_id,\n    customer_id,\n    CAST(from_iso8601_timestamp(timestamp) AS TIMESTAMP(6)) as reading_timestamp,\n    metrics_energy_kwh as energy_kwh,\n    metrics_voltage as voltage,\n    metrics_battery_pct as battery_pct,\n    status,\n    CAST(CURRENT_TIMESTAMP AS TIMESTAMP(6)) as ingested_at\nFROM source_data\n\n\n    WHERE CAST(from_iso8601_timestamp(timestamp) AS TIMESTAMP(6)) > (SELECT MAX(reading_timestamp) FROM \"iceberg\".\"energy_data_staging\".\"stg_telemetry_raw\")\n", "relation_name": "\"iceberg\".\"energy_data_staging\".\"stg_telemetry_raw\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-16T12:36:21.699591Z", "completed_at": "2025-12-16T12:36:21.707065Z"}, {"name": "execute", "started_at": "2025-12-16T12:36:21.708322Z", "completed_at": "2025-12-16T12:36:22.063112Z"}], "thread_id": "Thread-4 (worker)", "execution_time": 0.3694949150085449, "adapter_response": {"_message": "SUCCESS", "rows_affected": 10, "query": "/* {\"app\": \"dbt\", \"dbt_version\": \"1.7.0\", \"profile_name\": \"smart_energy_meter\", \"target_name\": \"dev\", \"node_id\": \"model.smart_energy_meter.device_daily_metrics\"} */\n\n  \n    \n\n    create table \"iceberg\".\"energy_data_marts\".\"device_daily_metrics__dbt_tmp\"\n      \n      \n    as (\n      \n\n-- Analytics model: Daily aggregated metrics per device\n-- Calculates total energy consumption, average voltage, and device health per day\n\nWITH daily_readings AS (\n    SELECT\n        device_id,\n        customer_id,\n        DATE(reading_timestamp) as reading_date,\n        SUM(energy_kwh) as total_energy_kwh,\n        AVG(voltage) as avg_voltage,\n        MIN(voltage) as min_voltage,\n        MAX(voltage) as max_voltage,\n        AVG(battery_pct) as avg_battery_pct,\n        COUNT(*) as reading_count,\n        SUM(CASE WHEN status = 'WARNING' THEN 1 ELSE 0 END) as warning_count,\n        SUM(CASE WHEN status = 'OK' THEN 1 ELSE 0 END) as ok_count\n    FROM \"iceberg\".\"energy_data_staging\".\"stg_telemetry_raw\"\n    GROUP BY\n        device_id,\n        customer_id,\n        DATE(reading_timestamp)\n)\n\nSELECT\n    device_id,\n    customer_id,\n    reading_date,\n    total_energy_kwh,\n    avg_voltage,\n    min_voltage,\n    max_voltage,\n    avg_battery_pct,\n    reading_count,\n    warning_count,\n    ok_count,\n    ROUND(CAST(ok_count AS DOUBLE) / NULLIF(reading_count, 0) * 100, 2) as health_score_pct,\n    CASE\n        WHEN warning_count > reading_count * 0.1 THEN 'UNHEALTHY'\n        WHEN warning_count > 0 THEN 'DEGRADED'\n        ELSE 'HEALTHY'\n    END as device_health_status\nFROM daily_readings\nORDER BY reading_date DESC, device_id\n    )", "query_id": "20251216_123325_01792_g7hqv"}, "message": "SUCCESS", "failures": null, "unique_id": "model.smart_energy_meter.device_daily_metrics", "compiled": true, "compiled_code": "\n\n-- Analytics model: Daily aggregated metrics per device\n-- Calculates total energy consumption, average voltage, and device health per day\n\nWITH daily_readings AS (\n    SELECT\n        device_id,\n        customer_id,\n        DATE(reading_timestamp) as reading_date,\n        SUM(energy_kwh) as total_energy_kwh,\n        AVG(voltage) as avg_voltage,\n        MIN(voltage) as min_voltage,\n        MAX(voltage) as max_voltage,\n        AVG(battery_pct) as avg_battery_pct,\n        COUNT(*) as reading_count,\n        SUM(CASE WHEN status = 'WARNING' THEN 1 ELSE 0 END) as warning_count,\n        SUM(CASE WHEN status = 'OK' THEN 1 ELSE 0 END) as ok_count\n    FROM \"iceberg\".\"energy_data_staging\".\"stg_telemetry_raw\"\n    GROUP BY\n        device_id,\n        customer_id,\n        DATE(reading_timestamp)\n)\n\nSELECT\n    device_id,\n    customer_id,\n    reading_date,\n    total_energy_kwh,\n    avg_voltage,\n    min_voltage,\n    max_voltage,\n    avg_battery_pct,\n    reading_count,\n    warning_count,\n    ok_count,\n    ROUND(CAST(ok_count AS DOUBLE) / NULLIF(reading_count, 0) * 100, 2) as health_score_pct,\n    CASE\n        WHEN warning_count > reading_count * 0.1 THEN 'UNHEALTHY'\n        WHEN warning_count > 0 THEN 'DEGRADED'\n        ELSE 'HEALTHY'\n    END as device_health_status\nFROM daily_readings\nORDER BY reading_date DESC, device_id", "relation_name": "\"iceberg\".\"energy_data_marts\".\"device_daily_metrics\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-12-16T12:36:22.070875Z", "completed_at": "2025-12-16T12:36:22.074674Z"}, {"name": "execute", "started_at": "2025-12-16T12:36:22.075612Z", "completed_at": "2025-12-16T12:36:22.344764Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.2774960994720459, "adapter_response": {"_message": "SUCCESS", "rows_affected": 5, "query": "/* {\"app\": \"dbt\", \"dbt_version\": \"1.7.0\", \"profile_name\": \"smart_energy_meter\", \"target_name\": \"dev\", \"node_id\": \"model.smart_energy_meter.customer_usage_summary\"} */\n\n  \n    \n\n    create table \"iceberg\".\"energy_data_marts\".\"customer_usage_summary__dbt_tmp\"\n      \n      \n    as (\n      \n\n-- Analytics model: Customer usage summary\n-- Aggregates energy consumption and device health metrics per customer\n\nWITH customer_metrics AS (\n    SELECT\n        customer_id,\n        reading_date,\n        SUM(total_energy_kwh) as daily_total_energy_kwh,\n        AVG(avg_voltage) as avg_voltage,\n        COUNT(DISTINCT device_id) as active_devices,\n        SUM(warning_count) as total_warnings,\n        SUM(reading_count) as total_readings,\n        AVG(health_score_pct) as avg_device_health_pct\n    FROM \"iceberg\".\"energy_data_marts\".\"device_daily_metrics\"\n    GROUP BY\n        customer_id,\n        reading_date\n)\n\nSELECT\n    customer_id,\n    reading_date,\n    daily_total_energy_kwh,\n    avg_voltage,\n    active_devices,\n    total_warnings,\n    total_readings,\n    ROUND(avg_device_health_pct, 2) as avg_device_health_pct,\n    CASE\n        WHEN total_warnings > total_readings * 0.05 THEN 'ACTION_REQUIRED'\n        WHEN total_warnings > 0 THEN 'MONITOR'\n        ELSE 'NORMAL'\n    END as customer_alert_status\nFROM customer_metrics\nORDER BY reading_date DESC, customer_id\n    )", "query_id": "20251216_123325_01796_g7hqv"}, "message": "SUCCESS", "failures": null, "unique_id": "model.smart_energy_meter.customer_usage_summary", "compiled": true, "compiled_code": "\n\n-- Analytics model: Customer usage summary\n-- Aggregates energy consumption and device health metrics per customer\n\nWITH customer_metrics AS (\n    SELECT\n        customer_id,\n        reading_date,\n        SUM(total_energy_kwh) as daily_total_energy_kwh,\n        AVG(avg_voltage) as avg_voltage,\n        COUNT(DISTINCT device_id) as active_devices,\n        SUM(warning_count) as total_warnings,\n        SUM(reading_count) as total_readings,\n        AVG(health_score_pct) as avg_device_health_pct\n    FROM \"iceberg\".\"energy_data_marts\".\"device_daily_metrics\"\n    GROUP BY\n        customer_id,\n        reading_date\n)\n\nSELECT\n    customer_id,\n    reading_date,\n    daily_total_energy_kwh,\n    avg_voltage,\n    active_devices,\n    total_warnings,\n    total_readings,\n    ROUND(avg_device_health_pct, 2) as avg_device_health_pct,\n    CASE\n        WHEN total_warnings > total_readings * 0.05 THEN 'ACTION_REQUIRED'\n        WHEN total_warnings > 0 THEN 'MONITOR'\n        ELSE 'NORMAL'\n    END as customer_alert_status\nFROM customer_metrics\nORDER BY reading_date DESC, customer_id", "relation_name": "\"iceberg\".\"energy_data_marts\".\"customer_usage_summary\""}], "elapsed_time": 1.8780763149261475, "args": {"populate_cache": true, "strict_mode": false, "exclude": [], "log_file_max_bytes": 10485760, "show_resource_report": false, "print": true, "use_colors": true, "version_check": true, "enable_legacy_logger": false, "macro_debugging": false, "log_level_file": "debug", "profiles_dir": "/dbt", "warn_error_options": {"include": [], "exclude": []}, "printer_width": 80, "use_colors_file": true, "indirect_selection": "eager", "vars": {}, "cache_selected_only": false, "partial_parse_file_diff": true, "favor_state": false, "select": [], "static_parser": true, "log_format": "default", "write_json": true, "quiet": false, "introspect": true, "defer": false, "invocation_command": "dbt run", "log_format_file": "debug", "log_path": "/dbt/logs", "project_dir": "/dbt", "which": "run", "log_level": "info", "partial_parse": true, "send_anonymous_usage_stats": true}}